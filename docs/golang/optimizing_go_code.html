<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tricky Interview Questions for Senior Golang Developers</title>
    <style id="tailwind-styles">
        *,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/*! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com*/*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb}:after,:before{--tw-content:""}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}.prose{color:var(--tw-prose-body);max-width:65ch}.prose :where(p):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em;margin-bottom:1.25em}.prose :where([class~=lead]):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-lead);font-size:1.25em;line-height:1.6;margin-top:1.2em;margin-bottom:1.2em}.prose :where(a):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-links);text-decoration:underline;font-weight:500}.prose :where(strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-bold);font-weight:600}.prose :where(a strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(blockquote strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(thead th strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(ol):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:decimal;margin-top:1.25em;margin-bottom:1.25em;padding-inline-start:1.625em}.prose :where(ol[type=A]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-alpha}.prose :where(ol[type=a]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-alpha}.prose :where(ol[type=A s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-alpha}.prose :where(ol[type=a s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-alpha}.prose :where(ol[type=I]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-roman}.prose :where(ol[type=i]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-roman}.prose :where(ol[type=I s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-roman}.prose :where(ol[type=i s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-roman}.prose :where(ol[type="1"]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:decimal}.prose :where(ul):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:disc;margin-top:1.25em;margin-bottom:1.25em;padding-inline-start:1.625em}.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker{font-weight:400;color:var(--tw-prose-counters)}.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker{color:var(--tw-prose-bullets)}.prose :where(dt):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;margin-top:1.25em}.prose :where(hr):not(:where([class~=not-prose],[class~=not-prose] *)){border-color:var(--tw-prose-hr);border-top-width:1px;margin-top:3em;margin-bottom:3em}.prose :where(blockquote):not(:where([class~=not-prose],[class~=not-prose] *)){font-weight:500;font-style:italic;color:var(--tw-prose-quotes);border-inline-start-width:.25rem;border-inline-start-color:var(--tw-prose-quote-borders);quotes:"\201C""\201D""\2018""\2019";margin-top:1.6em;margin-bottom:1.6em;padding-inline-start:1em}.prose :where(blockquote p:first-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:open-quote}.prose :where(blockquote p:last-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:close-quote}.prose :where(h1):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111}.prose :where(h1 strong):not(:where([class~=not-prose],[class~=not-prose] *)){font-weight:900;color:inherit}.prose :where(h2):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333}.prose :where(h2 strong):not(:where([class~=not-prose],[class~=not-prose] *)){font-weight:800;color:inherit}.prose :where(h3):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6}.prose :where(h3 strong):not(:where([class~=not-prose],[class~=not-prose] *)){font-weight:700;color:inherit}.prose :where(h4):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;margin-top:1.5em;margin-bottom:.5em;line-height:1.5}.prose :where(h4 strong):not(:where([class~=not-prose],[class~=not-prose] *)){font-weight:700;color:inherit}.prose :where(img):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:2em;margin-bottom:2em}.prose :where(picture):not(:where([class~=not-prose],[class~=not-prose] *)){display:block;margin-top:2em;margin-bottom:2em}.prose :where(video):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:2em;margin-bottom:2em}.prose :where(kbd):not(:where([class~=not-prose],[class~=not-prose] *)){font-weight:500;font-family:inherit;color:var(--tw-prose-kbd);box-shadow:0 0 0 1px rgb(var(--tw-prose-kbd-shadows)/10%),0 3px 0 rgb(var(--tw-prose-kbd-shadows)/10%);font-size:.875em;border-radius:.3125rem;padding-top:.1875em;padding-inline-end:.375em;padding-bottom:.1875em;padding-inline-start:.375em}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-code);font-weight:600;font-size:.875em}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:"`"}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:"`"}.prose :where(a code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(h1 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(h2 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-size:.875em}.prose :where(h3 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-size:.9em}.prose :where(h4 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(blockquote code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(thead th code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(pre):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-pre-code);background-color:var(--tw-prose-pre-bg);overflow-x:auto;font-weight:400;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding-top:.8571429em;padding-inline-end:1.1428571em;padding-bottom:.8571429em;padding-inline-start:1.1428571em}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)){background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:inherit;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:none}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:none}.prose :where(table):not(:where([class~=not-prose],[class~=not-prose] *)){width:100%;table-layout:auto;margin-top:2em;margin-bottom:2em;font-size:.875em;line-height:1.7142857}.prose :where(thead):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-width:1px;border-bottom-color:var(--tw-prose-th-borders)}.prose :where(thead th):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;vertical-align:bottom;padding-inline-end:.5714286em;padding-bottom:.5714286em;padding-inline-start:.5714286em}.prose :where(tbody tr):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-width:1px;border-bottom-color:var(--tw-prose-td-borders)}.prose :where(tbody tr:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-width:0}.prose :where(tbody td):not(:where([class~=not-prose],[class~=not-prose] *)){vertical-align:baseline}.prose :where(tfoot):not(:where([class~=not-prose],[class~=not-prose] *)){border-top-width:1px;border-top-color:var(--tw-prose-th-borders)}.prose :where(tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)){vertical-align:top}.prose :where(th,td):not(:where([class~=not-prose],[class~=not-prose] *)){text-align:start}.prose :where(figure>*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0;margin-bottom:0}.prose :where(figcaption):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-captions);font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.prose{--tw-prose-body:#374151;--tw-prose-headings:#111827;--tw-prose-lead:#4b5563;--tw-prose-links:#111827;--tw-prose-bold:#111827;--tw-prose-counters:#6b7280;--tw-prose-bullets:#d1d5db;--tw-prose-hr:#e5e7eb;--tw-prose-quotes:#111827;--tw-prose-quote-borders:#e5e7eb;--tw-prose-captions:#6b7280;--tw-prose-kbd:#111827;--tw-prose-kbd-shadows:17 24 39;--tw-prose-code:#111827;--tw-prose-pre-code:#e5e7eb;--tw-prose-pre-bg:#1f2937;--tw-prose-th-borders:#d1d5db;--tw-prose-td-borders:#e5e7eb;--tw-prose-invert-body:#d1d5db;--tw-prose-invert-headings:#fff;--tw-prose-invert-lead:#9ca3af;--tw-prose-invert-links:#fff;--tw-prose-invert-bold:#fff;--tw-prose-invert-counters:#9ca3af;--tw-prose-invert-bullets:#4b5563;--tw-prose-invert-hr:#374151;--tw-prose-invert-quotes:#f3f4f6;--tw-prose-invert-quote-borders:#374151;--tw-prose-invert-captions:#9ca3af;--tw-prose-invert-kbd:#fff;--tw-prose-invert-kbd-shadows:255 255 255;--tw-prose-invert-code:#fff;--tw-prose-invert-pre-code:#d1d5db;--tw-prose-invert-pre-bg:rgba(0,0,0,.5);--tw-prose-invert-th-borders:#4b5563;--tw-prose-invert-td-borders:#374151;font-size:1rem;line-height:1.75}.prose :where(picture>img):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0;margin-bottom:0}.prose :where(li):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:.5em;margin-bottom:.5em}.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *)){padding-inline-start:.375em}.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *)){padding-inline-start:.375em}.prose :where(.prose>ul>li p):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:.75em;margin-bottom:.75em}.prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em}.prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em}.prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em}.prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em}.prose :where(ul ul,ul ol,ol ul,ol ol):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:.75em;margin-bottom:.75em}.prose :where(dl):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em;margin-bottom:1.25em}.prose :where(dd):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:.5em;padding-inline-start:1.625em}.prose :where(hr+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h2+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h3+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h4+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(thead th:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-inline-start:0}.prose :where(thead th:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-inline-end:0}.prose :where(tbody td,tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)){padding-top:.5714286em;padding-inline-end:.5714286em;padding-bottom:.5714286em;padding-inline-start:.5714286em}.prose :where(tbody td:first-child,tfoot td:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-inline-start:0}.prose :where(tbody td:last-child,tfoot td:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-inline-end:0}.prose :where(figure):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:2em;margin-bottom:2em}.prose :where(.prose>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(.prose>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.isolate{isolation:isolate}.mx-auto{margin-left:auto;margin-right:auto}.mb-12{margin-bottom:3rem}.mt-12{margin-top:3rem}.block{display:block}.inline{display:inline}.flex{display:flex}.max-w-4xl{max-width:56rem}.max-w-none{max-width:none}.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.justify-between{justify-content:space-between}.border-b{border-bottom-width:1px}.border-t{border-top-width:1px}.border-gray-200{--tw-border-opacity:1;border-color:rgb(229 231 235/var(--tw-border-opacity,1))}.bg-gray-50{--tw-bg-opacity:1;background-color:rgb(249 250 251/var(--tw-bg-opacity,1))}.px-4{padding-left:1rem;padding-right:1rem}.py-8{padding-top:2rem;padding-bottom:2rem}.pb-6{padding-bottom:1.5rem}.pt-6{padding-top:1.5rem}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.text-blue-600{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity,1))}.underline{text-decoration-line:underline}.shadow{--tw-shadow:0 1px 3px 0 rgba(0,0,0,.1),0 1px 2px -1px rgba(0,0,0,.1);--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color),0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.\[b\:2\]{b:2}a{color:rgb(37 99 235/var(--tw-text-opacity,1));text-decoration-line:underline}a,a:hover{--tw-text-opacity:1}a:hover{color:rgb(30 64 175/var(--tw-text-opacity,1))}.prose a{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity,1));text-decoration-line:underline}.prose a:hover{--tw-text-opacity:1;color:rgb(30 64 175/var(--tw-text-opacity,1))}
    </style>
</head>
<body class="bg-gray-50">
    <div class="max-w-4xl mx-auto px-4 py-8">
        <header class="mb-12 border-b border-gray-200 pb-6 flex justify-between">
            <div><a href="memory_management.html" class="text-blue-600 nav-link">Previous</a></div>
            <div><a href="index.html" class="text-blue-600 nav-link">Table of Contents</a></div>
            <div><a href="reflection_use_cases.html" class="text-blue-600 nav-link">Next</a></div>
        </header>

        <main class="prose max-w-none">
            <h1>Tricky Interview Questions for Senior Golang Developers</h1>
<h3>Question 1: Understanding the <code>unsafe.Pointer</code> Type</h3>
<p><strong>Problem Statement:</strong></p>
<p>What is the <code>unsafe.Pointer</code> type in Go? How is it used, and what are the risks?</p>
<p><strong>Solution:</strong></p>
<p>The <code>unsafe.Pointer</code> type is a pointer type that represents a pointer to an arbitrary type. It allows you to bypass the type system and perform operations such as converting between different pointer types, accessing the memory of a struct field directly, and calling functions at arbitrary memory addresses.</p>
<p><strong>Explanation:</strong></p>
<p>The <code>unsafe.Pointer</code> type should only be used when absolutely necessary, as it can lead to undefined behavior, memory corruption, and security vulnerabilities. It should only be used when you need to perform operations that are not possible using the standard Go language features, such as interacting with hardware or implementing low-level data structures.</p>
<p>The risks of using the <code>unsafe.Pointer</code> type include:</p>
<ul>
<li><strong>Type safety violations:</strong> The <code>unsafe.Pointer</code> type allows you to bypass the type system, which can lead to type safety violations and undefined behavior.</li>
<li><strong>Memory corruption:</strong> The <code>unsafe.Pointer</code> type allows you to access memory directly, which can lead to memory corruption if you are not careful.</li>
<li><strong>Security vulnerabilities:</strong> The <code>unsafe.Pointer</code> type can be used to exploit security vulnerabilities in your code.</li>
<li><strong>Portability issues:</strong> Code that uses the <code>unsafe.Pointer</code> type may not be portable to different architectures or operating systems.</li>
</ul>
<h3>Question 2: Implementing a Simple Reflection-Based Deep Equal</h3>
<p><strong>Problem Statement:</strong></p>
<p>Implement a simple deep equal function in Go using reflection.</p>
<p><strong>Solution:</strong></p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"reflect"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeepEqual</span><span class="hljs-params">(a, b <span class="hljs-keyword">interface</span>{})</span></span> <span class="hljs-type">bool</span> {
	<span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> || b == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> a == b
	}

	valA := reflect.ValueOf(a)
	valB := reflect.ValueOf(b)

	<span class="hljs-keyword">if</span> valA.Type() != valB.Type() {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
	}

	<span class="hljs-keyword">if</span> valA.Kind() != reflect.Ptr &amp;&amp; valA.CanAddr() {
		valA = valA.Addr()
	}
	<span class="hljs-keyword">if</span> valB.Kind() != reflect.Ptr &amp;&amp; valB.CanAddr() {
		valB = valB.Addr()
	}

	<span class="hljs-keyword">if</span> valA.Kind() == reflect.Ptr {
		<span class="hljs-keyword">if</span> valA.IsNil() || valB.IsNil() {
			<span class="hljs-keyword">return</span> valA.IsNil() == valB.IsNil()
		}
		valA = valA.Elem()
		valB = valB.Elem()
	}

	<span class="hljs-keyword">switch</span> valA.Kind() {
	<span class="hljs-keyword">case</span> reflect.Slice, reflect.Array:
		<span class="hljs-keyword">if</span> valA.Len() != valB.Len() {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		}
		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; valA.Len(); i++ {
			<span class="hljs-keyword">if</span> !DeepEqual(valA.Index(i).Interface(), valB.Index(i).Interface()) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">case</span> reflect.Map:
		<span class="hljs-keyword">if</span> valA.Len() != valB.Len() {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
		}

		iterA := valA.MapRange()
		<span class="hljs-keyword">for</span> iterA.Next() {
			key := iterA.Key()
			valA := iterA.Value()
			valB := valB.MapIndex(key)
			<span class="hljs-keyword">if</span> !valB.IsValid() || !DeepEqual(valA.Interface(), valB.Interface()) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">case</span> reflect.Struct:
		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; valA.NumField(); i++ {
			<span class="hljs-keyword">if</span> !DeepEqual(valA.Field(i).Interface(), valB.Field(i).Interface()) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> reflect.DeepEqual(a, b)
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	a := []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
	b := []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
	c := []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>}

	fmt.Println(<span class="hljs-string">"a == b:"</span>, DeepEqual(a, b))
	fmt.Println(<span class="hljs-string">"a == c:"</span>, DeepEqual(a, c))

	map1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>{<span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"b"</span>: <span class="hljs-number">2</span>}
	map2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>{<span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"b"</span>: <span class="hljs-number">2</span>}
	map3 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>{<span class="hljs-string">"a"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"b"</span>: <span class="hljs-number">3</span>}

	fmt.Println(<span class="hljs-string">"map1 == map2:"</span>, DeepEqual(map1, map2))
	fmt.Println(<span class="hljs-string">"map1 == map3:"</span>, DeepEqual(map1, map3))
}
</code></pre>
<p><strong>Explanation:</strong></p>
<p>The <code>DeepEqual</code> function uses reflection to compare two values of any type. The function first checks if the two values are nil. If they are, the function returns true if both values are nil and false otherwise. If the two values are not nil, the function checks if they are of the same type. If they are not, the function returns false. If the two values are of the same type, the function checks if they are slices, maps, or structs. If they are, the function recursively calls the <code>DeepEqual</code> function to compare the elements of the slices, maps, or structs. If the two values are not slices, maps, or structs, the function uses the <code>reflect.DeepEqual</code> function to compare the two values.</p>
<h3>Question 3: Understanding the <code>reflect.Type</code> and <code>reflect.Value</code> Types</h3>
<p><strong>Problem Statement:</strong></p>
<p>What are the <code>reflect.Type</code> and <code>reflect.Value</code> types in Go? How are they used?</p>
<p><strong>Solution:</strong></p>
<p>The <code>reflect.Type</code> and <code>reflect.Value</code> types are used to represent the type and value of a Go variable at runtime. They are part of the <code>reflect</code> package, which provides support for reflection in Go.</p>
<p><strong>Explanation:</strong></p>
<p>The <code>reflect.Type</code> type represents the type of a Go variable. It provides methods for accessing information about the type, such as its name, kind, and size.</p>
<p>The <code>reflect.Value</code> type represents the value of a Go variable. It provides methods for accessing and modifying the value, such as getting and setting its fields, calling its methods, and converting it to other types.</p>
<h3>Question 4: Implementing a Simple Dependency Injection Container</h3>
<p><strong>Problem Statement:</strong></p>
<p>Implement a simple dependency injection container in Go using reflection.</p>
<p><strong>Solution:</strong></p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"reflect"</span>
)

<span class="hljs-keyword">type</span> Container <span class="hljs-keyword">struct</span> {
	dependencies <span class="hljs-keyword">map</span>[reflect.Type]reflect.Value
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewContainer</span><span class="hljs-params">()</span></span> *Container {
	<span class="hljs-keyword">return</span> &amp;Container{
		dependencies: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]reflect.Value),
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span></span> Register(dependency <span class="hljs-keyword">interface</span>{}) {
	val := reflect.ValueOf(dependency)
	typ := val.Type()

	<span class="hljs-keyword">if</span> typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}

	c.dependencies[typ] = val
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span></span> Resolve(target <span class="hljs-keyword">interface</span>{}) <span class="hljs-type">error</span> {
	targetType := reflect.TypeOf(target)
	<span class="hljs-keyword">if</span> targetType.Kind() != reflect.Ptr || targetType.Elem().Kind() != reflect.Struct {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"target must be a pointer to a struct"</span>)
	}

	targetValue := reflect.ValueOf(target).Elem()
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; targetType.Elem().NumField(); i++ {
		field := targetType.Elem().Field(i)
		fieldType := field.Type

		dependency, ok := c.dependencies[fieldType]
		<span class="hljs-keyword">if</span> !ok {
			<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"dependency not found for type %s"</span>, fieldType)
		}

		fieldValue := targetValue.Field(i)
		<span class="hljs-keyword">if</span> fieldValue.Kind() == reflect.Ptr {
			fieldValue.Set(dependency)
		} <span class="hljs-keyword">else</span> {
			fieldValue.Set(dependency.Elem())
		}
	}

	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}

<span class="hljs-keyword">type</span> Logger <span class="hljs-keyword">struct</span> {
	Prefix <span class="hljs-type">string</span>
}

<span class="hljs-keyword">type</span> App <span class="hljs-keyword">struct</span> {
	Logger *Logger
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	container := NewContainer()
	logger := &amp;Logger{Prefix: <span class="hljs-string">"MyApp"</span>}
	container.Register(logger)

	app := &amp;App{}
	err := container.Resolve(app)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"Error resolving dependencies:"</span>, err)
		<span class="hljs-keyword">return</span>
	}

	fmt.Println(<span class="hljs-string">"App:"</span>, app.Logger.Prefix)
}
</code></pre>
<p><strong>Explanation:</strong></p>
<p>The <code>Container</code> struct contains a map of dependencies. The <code>Register</code> method registers a dependency with the container. The <code>Resolve</code> method resolves the dependencies of a target struct.</p>
<h3>Question 5: Understanding the <code>reflect.SelectCase</code> Type</h3>
<p><strong>Problem Statement:</strong></p>
<p>What is the <code>reflect.SelectCase</code> type in Go? How is it used?</p>
<p><strong>Solution:</strong></p>
<p>The <code>reflect.SelectCase</code> type is used to represent a case in a <code>select</code> statement. It is part of the <code>reflect</code> package, which provides support for reflection in Go.</p>
<p><strong>Explanation:</strong></p>
<p>The <code>reflect.SelectCase</code> type has three fields:</p>
<ul>
<li><strong>Dir:</strong> The direction of the channel operation. It can be <code>reflect.SelectSend</code>, <code>reflect.SelectRecv</code>, or <code>reflect.SelectDefault</code>.</li>
<li><strong>Chan:</strong> The channel to send to or receive from.</li>
<li><strong>Send:</strong> The value to send to the channel.</li>
</ul>
<p>The <code>reflect.Select</code> function takes a slice of <code>reflect.SelectCase</code> values and executes the first case that is ready.</p>
<h3>Question 6: Implementing a Simple Mocking Framework</h3>
<p><strong>Problem Statement:</strong></p>
<p>Implement a simple mocking framework in Go using reflection.</p>
<p><strong>Solution:</strong></p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"reflect"</span>
)

<span class="hljs-keyword">type</span> Mock <span class="hljs-keyword">struct</span> {
	target <span class="hljs-keyword">interface</span>{}
	calls  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-keyword">interface</span>{}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMock</span><span class="hljs-params">(target <span class="hljs-keyword">interface</span>{})</span></span> *Mock {
	<span class="hljs-keyword">return</span> &amp;Mock{
		target: target,
		calls:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-keyword">interface</span>{}),
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mock)</span></span> On(methodName <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>{}) *Mock {
	m.calls[methodName] = args
	<span class="hljs-keyword">return</span> m
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mock)</span></span> Call(methodName <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>{}) []reflect.Value {
	val := reflect.ValueOf(m.target)
	method := val.MethodByName(methodName)

	<span class="hljs-keyword">if</span> !method.IsValid() {
		<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"Method %s not found"</span>, methodName))
	}

	<span class="hljs-keyword">if</span> expectedArgs, ok := m.calls[methodName]; ok {
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-built_in">len</span>(expectedArgs) {
			<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"Incorrect number of arguments for method %s"</span>, methodName))
		}

		in := <span class="hljs-built_in">make</span>([]reflect.Value, <span class="hljs-built_in">len</span>(args))
		<span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> args {
			in[i] = reflect.ValueOf(arg)
			<span class="hljs-keyword">if</span> in[i].Type() != reflect.TypeOf(expectedArgs[i]) {
				<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"Incorrect argument type for method %s"</span>, methodName))
			}
		}
		<span class="hljs-keyword">return</span> method.Call(in)
	}

	<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"Unexpected call to method %s"</span>, methodName))
}

<span class="hljs-keyword">type</span> MyInterface <span class="hljs-keyword">interface</span> {
	DoSomething(a <span class="hljs-type">int</span>, b <span class="hljs-type">string</span>) <span class="hljs-type">string</span>
}

<span class="hljs-keyword">type</span> MyImplementation <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyImplementation)</span></span> DoSomething(a <span class="hljs-type">int</span>, b <span class="hljs-type">string</span>) <span class="hljs-type">string</span> {
	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"Real implementation: %d %s"</span>, a, b)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	mock := NewMock(&amp;MyImplementation{})
	mock.On(<span class="hljs-string">"DoSomething"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>).Return(<span class="hljs-string">"Mocked result"</span>)

	result := mock.Call(<span class="hljs-string">"DoSomething"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>)[<span class="hljs-number">0</span>].String()
	fmt.Println(<span class="hljs-string">"Result:"</span>, result)
}
</code></pre>
<p><strong>Explanation:</strong></p>
<p>The <code>Mock</code> struct contains the target object and a map of expected calls. The <code>On</code> method registers an expected call with the mock. The <code>Call</code> method calls the method on the target object.</p>
<h3>Question 7: Understanding the <code>reflect.Swapper</code> Function</h3>
<p><strong>Problem Statement:</strong></p>
<p>What is the <code>reflect.Swapper</code> function in Go? How is it used?</p>
<p><strong>Solution:</strong></p>
<p>The <code>reflect.Swapper</code> function returns a function that swaps the elements at the specified indices in a slice. It is part of the <code>reflect</code> package, which provides support for reflection in Go.</p>
<p><strong>Explanation:</strong></p>
<p>The <code>reflect.Swapper</code> function takes a slice as an argument and returns a function that takes two integer indices as arguments. The returned function swaps the elements at the specified indices in the slice.</p>
<h3>Question 8: Implementing a Simple JSON Unmarshaler</h3>
<p><strong>Problem Statement:</strong></p>
<p>Implement a simple JSON unmarshaler in Go using reflection.</p>
<p><strong>Solution:</strong></p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"reflect"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, v <span class="hljs-keyword">interface</span>{})</span></span> <span class="hljs-type">error</span> {
	val := reflect.ValueOf(v)
	<span class="hljs-keyword">if</span> val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"v must be a pointer to a struct"</span>)
	}

	<span class="hljs-comment">// Use the standard json.Unmarshal to populate the struct</span>
	<span class="hljs-keyword">return</span> json.Unmarshal(data, v)
}

<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> {
	Name <span class="hljs-type">string</span> <span class="hljs-string">`json:"name"`</span>
	Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:"age"`</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	jsonData := []<span class="hljs-type">byte</span>(<span class="hljs-string">`{"name": "Alice", "age": 30}`</span>)
	person := &amp;Person{}

	err := Unmarshal(jsonData, person)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(<span class="hljs-string">"Error unmarshaling:"</span>, err)
		<span class="hljs-keyword">return</span>
	}

	fmt.Printf(<span class="hljs-string">"Name: %s, Age: %d\n"</span>, person.Name, person.Age)
}
</code></pre>
<p><strong>Explanation:</strong></p>
<p>The <code>Unmarshal</code> function uses reflection to check if the target is a pointer to a struct. If it is, the function uses the <code>json.Unmarshal</code> function to unmarshal the JSON data into the struct.</p>
<h3>Question 9: Understanding the <code>reflect.MakeFunc</code> Function</h3>
<p><strong>Problem Statement:</strong></p>
<p>What is the <code>reflect.MakeFunc</code> function in Go? How is it used?</p>
<p><strong>Solution:</strong></p>
<p>The <code>reflect.MakeFunc</code> function creates a new function value from a <code>reflect.Value</code> representing a function type and a function that implements the function’s behavior. It is part of the <code>reflect</code> package, which provides support for reflection in Go.</p>
<p><strong>Explanation:</strong></p>
<p>The <code>reflect.MakeFunc</code> function takes a <code>reflect.Type</code> representing a function type and a function that implements the function’s behavior. The returned <code>reflect.Value</code> represents a new function value that has the specified type and behavior.</p>
<h3>Question 10: Implementing a Simple Plugin System</h3>
<p><strong>Problem Statement:</strong></p>
<p>Implement a simple plugin system in Go using reflection.</p>
<p><strong>Solution:</strong></p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"plugin"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-comment">// Load the plugin</span>
	plug, err := plugin.Open(<span class="hljs-string">"myplugin.so"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(err)
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// Look up a symbol in the plugin</span>
	sym, err := plug.Lookup(<span class="hljs-string">"MyFunction"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		fmt.Println(err)
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// Assert that the symbol is a function of the correct type</span>
	<span class="hljs-keyword">var</span> myFunction <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>
	myFunction, ok := sym.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>)
	<span class="hljs-keyword">if</span> !ok {
		fmt.Println(<span class="hljs-string">"unexpected type from module symbol"</span>)
		<span class="hljs-keyword">return</span>
	}

	<span class="hljs-comment">// Use the function</span>
	result := myFunction(<span class="hljs-number">10</span>)
	fmt.Println(<span class="hljs-string">"Result from plugin:"</span>, result)
}
</code></pre>
<p><strong>Explanation:</strong></p>
<p>This example demonstrates loading a plugin and calling a function defined within it. The <code>plugin.Open</code> function loads the plugin, and the <code>plug.Lookup</code> function finds a symbol (in this case, a function) within the plugin. The symbol is then asserted to be of the correct type before being called.</p>

        </main>

        <footer class="mt-12 border-t border-gray-200 pt-6 flex justify-between">
            <div><a href="memory_management.html" class="text-blue-600 nav-link">Previous</a></div>
            <div><a href="index.html" class="text-blue-600 nav-link">Table of Contents</a></div>
            <div><a href="reflection_use_cases.html" class="text-blue-600 nav-link">Next</a></div>
        </footer>
    </div>
    <script>
        async function runCode(codeElementId, outputElementId, language) {
            const codeElement = document.getElementById(codeElementId);
            const outputElement = document.getElementById(outputElementId);
            const code = codeElement.textContent;
            outputElement.innerHTML = 'Running...';

            try {
                if (language === 'go') {
                    // Load wasm_exec.js if not already loaded
                    if (!window.Go) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = '../wasm/wasm_exec.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                    }

                    // Initialize Go Wasm instance if not already done
                    if (!window.goRunnerInstance) {
                        const go = new Go();
                        const result = await WebAssembly.instantiateStreaming(
                            fetch('../wasm/go_runner.wasm'),
                            go.importObject
                        );
                        window.goRunnerInstance = result.instance;
                        go.run(window.goRunnerInstance);
                    }

                    // Execute the code
                    const result = await window.executeGoCode(code);
                    if (result.error) {
                        outputElement.innerHTML = `<pre style="color: red;">Error:\n${result.error}</pre>`;
                    } else {
                        outputElement.innerHTML = `<pre>Output:\n${result.output}</pre>`;
                    }
                } else if (language === 'csharp') {
                    if (!window.csharpWasmRuntimeStarted) {
                        outputElement.innerHTML = 'Loading .NET Wasm runtime...';
                        try {
                            // Dynamically load blazor.webassembly.js if not already present
                            if (!document.querySelector('script[src="../wasm/csharp/blazor.webassembly.js"]')) {
                                const script = document.createElement('script');
                                script.src = '../wasm/csharp/blazor.webassembly.js';
                                script.defer = true;
                                document.body.appendChild(script);

                                // Wait for DotNet to be available
                                await new Promise(resolve => {
                                    const interval = setInterval(() => {
                                        if (window.DotNet && typeof window.DotNet.invokeMethodAsync === 'function') {
                                            clearInterval(interval);
                                            resolve();
                                        }
                                    }, 100);
                                });
                            } else {
                                // If script tag exists, still wait for DotNet to be ready
                                await new Promise(resolve => {
                                    const interval = setInterval(() => {
                                        if (window.DotNet && typeof window.DotNet.invokeMethodAsync === 'function') {
                                            clearInterval(interval);
                                            resolve();
                                        }
                                    }, 100);
                                });
                            }
                            window.csharpWasmRuntimeStarted = true;
                            outputElement.innerHTML = '.NET Wasm runtime loaded. Ready to run C# code.';
                        } catch (loadError) {
                            console.error("Error loading .NET Wasm runtime:", loadError);
                            outputElement.innerHTML = `<pre style="color: red;">Error loading .NET Wasm runtime:\n${loadError}</pre>`;
                            return;
                        }
                    }

                    try {
                        outputElement.innerHTML = 'Executing C# code...';
                        if (!(window.DotNet && typeof window.DotNet.invokeMethodAsync === 'function')) {
                            outputElement.innerHTML = `<pre style="color: red;">.NET runtime not available for invoking method.</pre>`;
                            return;
                        }

                        const result = await window.DotNet.invokeMethodAsync('CSharpWasmRunner', 'ExecuteCodeAsync', code);
                        if (result.error) {
                            outputElement.innerHTML = `<pre style="color: red;">Error:\n${result.error}</pre>`;
                        } else {
                            outputElement.innerHTML = `<pre>Output:\n${result.output}</pre>`;
                        }
                    } catch (execError) {
                        console.error("Error executing C# code:", execError);
                        outputElement.innerHTML = `<pre style="color: red;">Error executing C# code:\n${execError.message || execError}</pre>`;
                    }
                } else {
                    outputElement.innerHTML = `<p>Execution for ${language} is not supported.</p>`;
                }
            } catch (error) {
                outputElement.innerHTML = `<pre style="color: red;">Error:\n${error.message}</pre>`;
                console.error('Code execution error:', error);
            }
        }
    </script>
</body>
</html>